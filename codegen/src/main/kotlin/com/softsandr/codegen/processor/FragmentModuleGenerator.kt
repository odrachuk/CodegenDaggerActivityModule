package com.softsandr.codegen.processor

import com.softsandr.codegen.annotation.FragmentModuleClass
import com.softsandr.codegen.annotation.GenerateFragmentModule
import com.softsandr.codegen.exception.ClassPackageNotFoundException
import com.softsandr.codegen.utils.Utils
import com.squareup.javapoet.AnnotationSpec
import com.squareup.javapoet.ClassName
import com.squareup.javapoet.JavaFile
import com.squareup.javapoet.MethodSpec
import com.squareup.javapoet.TypeSpec
import java.io.IOException
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.element.Modifier
import javax.lang.model.element.TypeElement
import javax.lang.model.type.MirroredTypesException

internal object FragmentModuleGenerator {
    val FRG_MODULE_ANNOTATION = GenerateFragmentModule::class.java

    /**
     * Use this method to get list of [FragmentModuleClass] wrappers that represent fragments from
     * GenerateActivityModule.fragments
     * @param   frModuleElements all fragments annotated by [GenerateFragmentModule]
     * @param   activityFragments list of Fragments' classes for a particular Activity
     */
    fun filterFragmentElements(frModuleElements: List<TypeElement>,
                               activityFragments: List<String>): List<FragmentModuleClass> {
        return frModuleElements
                .filter { it -> activityFragments.contains(it.asType().toString()) }
                .map { it ->
                    val annotation = it.getAnnotation(FRG_MODULE_ANNOTATION)
                    val modules: List<String>? = try {
                        annotation?.modules?.map { module -> module.qualifiedName + ".class" }
                    } catch (ex: MirroredTypesException) {
                        ex.typeMirrors?.map { module -> module.toString() + ".class" }
                    }
                    FragmentModuleClass(it, modules ?: emptyList())
                }
    }

    /**
     * Used to generate Dagger2's module for a Fragment
     */
    @Throws(ClassPackageNotFoundException::class, AssertionError::class)
    fun buildFragmentModuleType(processingEnv: ProcessingEnvironment,
                                frgModuleClass: FragmentModuleClass,
                                generatedTypes: MutableSet<String>) {
        val frgClassName = frgModuleClass.element.asType().toString().split(".").last()
        if (!generatedTypes.contains(frgClassName)) {
            val builder = TypeSpec.classBuilder(frgClassName + DaggerModulesProcessor.MODULE_SUFFIX)
                    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
            builder.addJavadoc("Class is generated by {@link com.softsandr.codegen.DaggerModulesProcessor}")
            builder.addAnnotation(Class.forName("dagger.Module"))
            builder.addMethod(generateFragmentProvideMethod(frgModuleClass))

            val packageName = Utils.getPackageName(processingEnv.elementUtils, frgModuleClass.element)
            val generatedType = builder.build()
            try {
                val javaFileBuilder = JavaFile.builder(packageName, generatedType).build()
                javaFileBuilder.writeTo(processingEnv.filer)
                generatedTypes.add(frgClassName)
            } catch (e: IOException) {
                throw AssertionError(e)
            }
        }
    }

    /**
     * Used to generate provide*() method for a Fragment
     */
    private fun generateFragmentProvideMethod(frgModuleClass: FragmentModuleClass): MethodSpec {
        val className = frgModuleClass.element.asType().toString().split(".").last()

        val annotationBuilder = AnnotationSpec.builder(Class.forName(
                "dagger.android.ContributesAndroidInjector"))
        if (!frgModuleClass.dependencies.isEmpty()) {
            val fragmentsModules = frgModuleClass.dependencies.toString()
                    .removePrefix("[")
                    .removeSuffix("]")
            annotationBuilder.addMember("modules", "{\$L}", fragmentsModules)
        }

        val methodBuilder = MethodSpec.methodBuilder("provide$className")
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .addAnnotation(ClassName.get(DaggerModulesProcessor.SCOPE_PACKAGE, DaggerModulesProcessor.FRAGMENT_SCOPE))
                .addAnnotation(annotationBuilder.build())
                .returns(ClassName.get(frgModuleClass.element.asType()))

        return methodBuilder.build()
    }
}