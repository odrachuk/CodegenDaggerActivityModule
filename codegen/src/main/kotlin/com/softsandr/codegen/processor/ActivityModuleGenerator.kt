package com.softsandr.codegen.processor

import com.softsandr.codegen.annotation.ActivityModuleClass
import com.softsandr.codegen.annotation.GenerateActivityModule
import com.softsandr.codegen.exception.ClassPackageNotFoundException
import com.softsandr.codegen.utils.Utils
import com.squareup.javapoet.AnnotationSpec
import com.squareup.javapoet.ClassName
import com.squareup.javapoet.JavaFile
import com.squareup.javapoet.MethodSpec
import com.squareup.javapoet.TypeSpec
import java.io.IOException
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.element.Modifier


internal object ActivityModuleGenerator {
    val ACT_MODULE_ANNOTATION = GenerateActivityModule::class.java

    /**
     * Used to generated Dagger2's modules for Activities
     * @param   moduleClasses should contain list of wrapper-classes with info from GenerateActivityModule annotation
     * @param   generatedTypes is a simple Set of generated .java-files. Used to prevent duplicating exceptions
     */
    @Throws(ClassPackageNotFoundException::class, AssertionError::class)
    fun generateModulesClasses(processingEnv: ProcessingEnvironment,
                               moduleClasses: List<ActivityModuleClass>,
                               generatedTypes: MutableSet<String>) {
        if (moduleClasses.isEmpty()) {
            return
        }

        for (moduleClass in moduleClasses) {
            val actClassName = moduleClass.element.asType().toString().split(".").last()
            if (!generatedTypes.contains(actClassName)) { // checking if target file has not been generated before
                val generatedType = buildActivityModuleType(processingEnv, moduleClass, generatedTypes)
                try {
                    val packageName = Utils.getPackageName(processingEnv.elementUtils, moduleClass.element)
                    val javaFileBuilder = JavaFile.builder(packageName, generatedType).build()
                    javaFileBuilder.writeTo(processingEnv.filer) // writing .java-file
                    generatedTypes.add(actClassName) // remembering type of .java-file
                } catch (e: IOException) {
                    throw AssertionError(e)
                }
            }
        }
    }

    /**
     * Method builds instance of TypeSpec for an Activity
     * @param   actModuleClass is a wrapper with information for an Activity
     * @param   generatedTypes is a Set of classes that have been generated already
     */
    private fun buildActivityModuleType(processingEnv: ProcessingEnvironment,
                                        actModuleClass: ActivityModuleClass,
                                        generatedTypes: MutableSet<String>): TypeSpec {
        val actClassName = actModuleClass.element.asType().toString()
                .split(".").last() + DaggerModulesProcessor.MODULE_SUFFIX // simple class name + "DaggerModule"
        val builder = TypeSpec.classBuilder(actClassName)
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
        builder.addJavadoc("Class is generated by {@link com.softsandr.codegen.DaggerModulesProcessor}")
        builder.addAnnotation(Class.forName("dagger.Module"))

        // all fragments' java-files should be generated before we can refer on them from the Activity's module
        for (fragmentModuleClass in actModuleClass.fragments) {
            FragmentModuleGenerator.buildFragmentModuleType(processingEnv, fragmentModuleClass, generatedTypes)
        }

        // provide method with ContributesAndroidInjector annotation for the Activity
        builder.addMethod(generateActivityProvideMethod(actModuleClass))

        return builder.build()
    }

    /**
     * Method builds instance of MethodSpec for the provide*() method
     * @param actModuleClass is a wrapper with information for an Activity
     */
    private fun generateActivityProvideMethod(actModuleClass: ActivityModuleClass): MethodSpec {
        val className = actModuleClass.element.asType().toString().split(".").last() // simple class name

        // a builder of "ContributesAndroidInjector" for the method
        val annotationBuilder = AnnotationSpec.builder(Class.forName(
                "dagger.android.ContributesAndroidInjector"))

        // a list of arguments for ContributesAndroidInjector.modules parameter
        val modulesStringBuilder = StringBuilder()
        // comma separated list of classes of external modules
        if (!actModuleClass.dependencies.isEmpty()) {
            val otherModules = actModuleClass.dependencies.toString()
                    .removePrefix("[")
                    .removeSuffix("]")
            modulesStringBuilder.append(otherModules)
        }
        // comma separated list of classes of fragments' dagger-modules
        if (!actModuleClass.fragments.isEmpty()) {
            val fragmentsModules = actModuleClass.fragments
                    .map { it -> it.element.asType().toString() + "DaggerModule.class" }
                    .toString()
                    .removePrefix("[")
                    .removeSuffix("]")
            if (modulesStringBuilder.isNotBlank()) {
                modulesStringBuilder.append(", ")
            }
            modulesStringBuilder.append(fragmentsModules)
        }

        // all together arguments for the "modules" parameter
        if (modulesStringBuilder.isNotBlank()) {
            annotationBuilder.addMember("modules", "{\$L}", modulesStringBuilder.toString())
        }

        val methodBuilder = MethodSpec.methodBuilder("provide$className")
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .addAnnotation(ClassName.get(DaggerModulesProcessor.SCOPE_PACKAGE, DaggerModulesProcessor.ACTIVITY_SCOPE))
                .addAnnotation(annotationBuilder.build())
                .returns(ClassName.get(actModuleClass.element.asType()))

        return methodBuilder.build()
    }
}